"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SolidityImportVisitor_inputContent, _SolidityImportVisitor_antlrTree, _ImportDefinitionVisitor_onVisit;
Object.defineProperty(exports, "__esModule", { value: true });
exports.SolidityImportVisitor = void 0;
const antlr4ts_1 = require("antlr4ts");
const ParseTreeWalker_1 = require("antlr4ts/tree/ParseTreeWalker");
const SolidityLexer_1 = require("../generated/SolidityLexer");
const SolidityParser_1 = require("../generated/SolidityParser");
class SolidityImportVisitor {
    constructor(inputContent) {
        _SolidityImportVisitor_inputContent.set(this, void 0);
        _SolidityImportVisitor_antlrTree.set(this, void 0);
        __classPrivateFieldSet(this, _SolidityImportVisitor_inputContent, inputContent, "f");
        const chars = antlr4ts_1.CharStreams.fromString(__classPrivateFieldGet(this, _SolidityImportVisitor_inputContent, "f"));
        const lexer = new SolidityLexer_1.SolidityLexer(chars);
        const tokens = new antlr4ts_1.CommonTokenStream(lexer);
        const parser = new SolidityParser_1.SolidityParser(tokens);
        __classPrivateFieldSet(this, _SolidityImportVisitor_antlrTree, parser.sourceUnit(), "f");
    }
    visit(onVisit) {
        const listener = new ImportDefinitionVisitor(onVisit);
        ParseTreeWalker_1.ParseTreeWalker.DEFAULT.walk(listener, __classPrivateFieldGet(this, _SolidityImportVisitor_antlrTree, "f"));
    }
}
exports.SolidityImportVisitor = SolidityImportVisitor;
_SolidityImportVisitor_inputContent = new WeakMap(), _SolidityImportVisitor_antlrTree = new WeakMap();
class ImportDefinitionVisitor {
    constructor(onVisit) {
        _ImportDefinitionVisitor_onVisit.set(this, void 0);
        __classPrivateFieldSet(this, _ImportDefinitionVisitor_onVisit, onVisit, "f");
    }
    enterImportDirective(ctx) {
        if (!ctx.children) {
            return;
        }
        if (!ctx._stop) {
            return;
        }
        const filename = this.getFilename(ctx);
        const globalRename = this.getGlobalRename(ctx);
        const namedImports = this.getNamedImports(ctx);
        __classPrivateFieldGet(this, _ImportDefinitionVisitor_onVisit, "f").call(this, {
            start: ctx._start.startIndex,
            end: ctx._stop.stopIndex,
            filename,
            globalRename,
            namedImports,
        });
    }
    getFilename(ctx) {
        var _a;
        const filename = (_a = ctx.path()) === null || _a === void 0 ? void 0 : _a.text;
        if (!filename) {
            throw new Error('Unable to fid path of the import');
        }
        return filename.substring(1).substring(0, filename.length - 2);
    }
    getGlobalRename(ctx) {
        var _a;
        if (!((_a = ctx.children) === null || _a === void 0 ? void 0 : _a.length)) {
            return null;
        }
        const last = ctx.children[ctx.children.length - 2];
        if (last && last instanceof SolidityParser_1.IdentifierContext) {
            return last.text;
        }
        const second = ctx.children[1];
        const forth = ctx.children[3];
        if (second.text === '*' && forth && forth instanceof SolidityParser_1.IdentifierContext) {
            return forth.text;
        }
        return null;
    }
    getNamedImports(ctx) {
        var _a;
        const importAliases = (_a = ctx.symbolAliases()) === null || _a === void 0 ? void 0 : _a.importAliases();
        if (!importAliases) {
            return null;
        }
        const result = [];
        importAliases.forEach((ia) => {
            var _a;
            const [i, rename] = ia.identifier();
            result.push({
                name: i.text,
                as: (_a = rename === null || rename === void 0 ? void 0 : rename.text) !== null && _a !== void 0 ? _a : null,
            });
        });
        return result;
    }
}
_ImportDefinitionVisitor_onVisit = new WeakMap();
//# sourceMappingURL=importVisitor.js.map