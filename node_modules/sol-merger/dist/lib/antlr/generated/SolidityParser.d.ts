import { ATN } from "antlr4ts/atn/ATN";
import { FailedPredicateException } from "antlr4ts/FailedPredicateException";
import { Parser } from "antlr4ts/Parser";
import { ParserRuleContext } from "antlr4ts/ParserRuleContext";
import { RuleContext } from "antlr4ts/RuleContext";
import { TerminalNode } from "antlr4ts/tree/TerminalNode";
import { Token } from "antlr4ts/Token";
import { TokenStream } from "antlr4ts/TokenStream";
import { Vocabulary } from "antlr4ts/Vocabulary";
import { SolidityParserListener } from "./SolidityParserListener";
import { SolidityParserVisitor } from "./SolidityParserVisitor";
export declare class SolidityParser extends Parser {
    static readonly ReservedKeywords = 1;
    static readonly Abstract = 2;
    static readonly Address = 3;
    static readonly Anonymous = 4;
    static readonly As = 5;
    static readonly Assembly = 6;
    static readonly Bool = 7;
    static readonly Break = 8;
    static readonly Bytes = 9;
    static readonly Calldata = 10;
    static readonly Catch = 11;
    static readonly Constant = 12;
    static readonly Constructor = 13;
    static readonly Continue = 14;
    static readonly Contract = 15;
    static readonly Delete = 16;
    static readonly Do = 17;
    static readonly Else = 18;
    static readonly Emit = 19;
    static readonly Enum = 20;
    static readonly Error = 21;
    static readonly Event = 22;
    static readonly External = 23;
    static readonly Fallback = 24;
    static readonly False = 25;
    static readonly Fixed = 26;
    static readonly FixedBytes = 27;
    static readonly For = 28;
    static readonly From = 29;
    static readonly Function = 30;
    static readonly Global = 31;
    static readonly Hex = 32;
    static readonly If = 33;
    static readonly Immutable = 34;
    static readonly Import = 35;
    static readonly Indexed = 36;
    static readonly Interface = 37;
    static readonly Internal = 38;
    static readonly Is = 39;
    static readonly Library = 40;
    static readonly Mapping = 41;
    static readonly Memory = 42;
    static readonly Modifier = 43;
    static readonly New = 44;
    static readonly NumberUnit = 45;
    static readonly Override = 46;
    static readonly Payable = 47;
    static readonly Pragma = 48;
    static readonly Private = 49;
    static readonly Public = 50;
    static readonly Pure = 51;
    static readonly Receive = 52;
    static readonly Return = 53;
    static readonly Returns = 54;
    static readonly Revert = 55;
    static readonly SignedIntegerType = 56;
    static readonly Storage = 57;
    static readonly String = 58;
    static readonly Struct = 59;
    static readonly True = 60;
    static readonly Try = 61;
    static readonly Type = 62;
    static readonly Ufixed = 63;
    static readonly Unchecked = 64;
    static readonly UnsignedIntegerType = 65;
    static readonly Using = 66;
    static readonly View = 67;
    static readonly Virtual = 68;
    static readonly While = 69;
    static readonly LParen = 70;
    static readonly RParen = 71;
    static readonly LBrack = 72;
    static readonly RBrack = 73;
    static readonly LBrace = 74;
    static readonly RBrace = 75;
    static readonly Colon = 76;
    static readonly Semicolon = 77;
    static readonly Period = 78;
    static readonly Conditional = 79;
    static readonly DoubleArrow = 80;
    static readonly RightArrow = 81;
    static readonly Assign = 82;
    static readonly AssignBitOr = 83;
    static readonly AssignBitXor = 84;
    static readonly AssignBitAnd = 85;
    static readonly AssignShl = 86;
    static readonly AssignSar = 87;
    static readonly AssignShr = 88;
    static readonly AssignAdd = 89;
    static readonly AssignSub = 90;
    static readonly AssignMul = 91;
    static readonly AssignDiv = 92;
    static readonly AssignMod = 93;
    static readonly Comma = 94;
    static readonly Or = 95;
    static readonly And = 96;
    static readonly BitOr = 97;
    static readonly BitXor = 98;
    static readonly BitAnd = 99;
    static readonly Shl = 100;
    static readonly Sar = 101;
    static readonly Shr = 102;
    static readonly Add = 103;
    static readonly Sub = 104;
    static readonly Mul = 105;
    static readonly Div = 106;
    static readonly Mod = 107;
    static readonly Exp = 108;
    static readonly Equal = 109;
    static readonly NotEqual = 110;
    static readonly LessThan = 111;
    static readonly GreaterThan = 112;
    static readonly LessThanOrEqual = 113;
    static readonly GreaterThanOrEqual = 114;
    static readonly Not = 115;
    static readonly BitNot = 116;
    static readonly Inc = 117;
    static readonly Dec = 118;
    static readonly DoubleQuote = 119;
    static readonly SingleQuote = 120;
    static readonly NonEmptyStringLiteral = 121;
    static readonly EmptyStringLiteral = 122;
    static readonly UnicodeStringLiteral = 123;
    static readonly HexString = 124;
    static readonly HexNumber = 125;
    static readonly DecimalNumber = 126;
    static readonly Identifier = 127;
    static readonly WS = 128;
    static readonly COMMENT = 129;
    static readonly LINE_COMMENT = 130;
    static readonly AssemblyDialect = 131;
    static readonly AssemblyLBrace = 132;
    static readonly AssemblyFlagString = 133;
    static readonly AssemblyBlockLParen = 134;
    static readonly AssemblyBlockRParen = 135;
    static readonly AssemblyBlockComma = 136;
    static readonly AssemblyBlockWS = 137;
    static readonly AssemblyBlockCOMMENT = 138;
    static readonly AssemblyBlockLINE_COMMENT = 139;
    static readonly YulBreak = 140;
    static readonly YulCase = 141;
    static readonly YulContinue = 142;
    static readonly YulDefault = 143;
    static readonly YulFalse = 144;
    static readonly YulFor = 145;
    static readonly YulFunction = 146;
    static readonly YulIf = 147;
    static readonly YulLeave = 148;
    static readonly YulLet = 149;
    static readonly YulSwitch = 150;
    static readonly YulTrue = 151;
    static readonly YulHex = 152;
    static readonly YulEVMBuiltin = 153;
    static readonly YulLBrace = 154;
    static readonly YulRBrace = 155;
    static readonly YulLParen = 156;
    static readonly YulRParen = 157;
    static readonly YulAssign = 158;
    static readonly YulPeriod = 159;
    static readonly YulComma = 160;
    static readonly YulArrow = 161;
    static readonly YulIdentifier = 162;
    static readonly YulHexNumber = 163;
    static readonly YulDecimalNumber = 164;
    static readonly YulStringLiteral = 165;
    static readonly YulHexStringLiteral = 166;
    static readonly YulWS = 167;
    static readonly YulCOMMENT = 168;
    static readonly YulLINE_COMMENT = 169;
    static readonly PragmaToken = 170;
    static readonly PragmaSemicolon = 171;
    static readonly PragmaWS = 172;
    static readonly PragmaCOMMENT = 173;
    static readonly PragmaLINE_COMMENT = 174;
    static readonly RULE_sourceUnit = 0;
    static readonly RULE_pragmaDirective = 1;
    static readonly RULE_importDirective = 2;
    static readonly RULE_importAliases = 3;
    static readonly RULE_path = 4;
    static readonly RULE_symbolAliases = 5;
    static readonly RULE_contractDefinition = 6;
    static readonly RULE_interfaceDefinition = 7;
    static readonly RULE_libraryDefinition = 8;
    static readonly RULE_inheritanceSpecifierList = 9;
    static readonly RULE_inheritanceSpecifier = 10;
    static readonly RULE_contractBodyElement = 11;
    static readonly RULE_namedArgument = 12;
    static readonly RULE_callArgumentList = 13;
    static readonly RULE_identifierPath = 14;
    static readonly RULE_modifierInvocation = 15;
    static readonly RULE_visibility = 16;
    static readonly RULE_parameterList = 17;
    static readonly RULE_parameterDeclaration = 18;
    static readonly RULE_constructorDefinition = 19;
    static readonly RULE_stateMutability = 20;
    static readonly RULE_overrideSpecifier = 21;
    static readonly RULE_functionDefinition = 22;
    static readonly RULE_modifierDefinition = 23;
    static readonly RULE_fallbackFunctionDefinition = 24;
    static readonly RULE_receiveFunctionDefinition = 25;
    static readonly RULE_structDefinition = 26;
    static readonly RULE_structMember = 27;
    static readonly RULE_enumDefinition = 28;
    static readonly RULE_userDefinedValueTypeDefinition = 29;
    static readonly RULE_stateVariableDeclaration = 30;
    static readonly RULE_constantVariableDeclaration = 31;
    static readonly RULE_eventParameter = 32;
    static readonly RULE_eventDefinition = 33;
    static readonly RULE_errorParameter = 34;
    static readonly RULE_errorDefinition = 35;
    static readonly RULE_userDefinableOperator = 36;
    static readonly RULE_usingDirective = 37;
    static readonly RULE_typeName = 38;
    static readonly RULE_elementaryTypeName = 39;
    static readonly RULE_functionTypeName = 40;
    static readonly RULE_variableDeclaration = 41;
    static readonly RULE_dataLocation = 42;
    static readonly RULE_expression = 43;
    static readonly RULE_assignOp = 44;
    static readonly RULE_tupleExpression = 45;
    static readonly RULE_inlineArrayExpression = 46;
    static readonly RULE_identifier = 47;
    static readonly RULE_literal = 48;
    static readonly RULE_booleanLiteral = 49;
    static readonly RULE_stringLiteral = 50;
    static readonly RULE_hexStringLiteral = 51;
    static readonly RULE_unicodeStringLiteral = 52;
    static readonly RULE_numberLiteral = 53;
    static readonly RULE_block = 54;
    static readonly RULE_uncheckedBlock = 55;
    static readonly RULE_statement = 56;
    static readonly RULE_simpleStatement = 57;
    static readonly RULE_ifStatement = 58;
    static readonly RULE_forStatement = 59;
    static readonly RULE_whileStatement = 60;
    static readonly RULE_doWhileStatement = 61;
    static readonly RULE_continueStatement = 62;
    static readonly RULE_breakStatement = 63;
    static readonly RULE_tryStatement = 64;
    static readonly RULE_catchClause = 65;
    static readonly RULE_returnStatement = 66;
    static readonly RULE_emitStatement = 67;
    static readonly RULE_revertStatement = 68;
    static readonly RULE_assemblyStatement = 69;
    static readonly RULE_assemblyFlags = 70;
    static readonly RULE_variableDeclarationList = 71;
    static readonly RULE_variableDeclarationTuple = 72;
    static readonly RULE_variableDeclarationStatement = 73;
    static readonly RULE_expressionStatement = 74;
    static readonly RULE_mappingType = 75;
    static readonly RULE_mappingKeyType = 76;
    static readonly RULE_yulStatement = 77;
    static readonly RULE_yulBlock = 78;
    static readonly RULE_yulVariableDeclaration = 79;
    static readonly RULE_yulAssignment = 80;
    static readonly RULE_yulIfStatement = 81;
    static readonly RULE_yulForStatement = 82;
    static readonly RULE_yulSwitchCase = 83;
    static readonly RULE_yulSwitchStatement = 84;
    static readonly RULE_yulFunctionDefinition = 85;
    static readonly RULE_yulPath = 86;
    static readonly RULE_yulFunctionCall = 87;
    static readonly RULE_yulBoolean = 88;
    static readonly RULE_yulLiteral = 89;
    static readonly RULE_yulExpression = 90;
    static readonly ruleNames: string[];
    private static readonly _LITERAL_NAMES;
    private static readonly _SYMBOLIC_NAMES;
    static readonly VOCABULARY: Vocabulary;
    get vocabulary(): Vocabulary;
    get grammarFileName(): string;
    get ruleNames(): string[];
    get serializedATN(): string;
    protected createFailedPredicateException(predicate?: string, message?: string): FailedPredicateException;
    constructor(input: TokenStream);
    sourceUnit(): SourceUnitContext;
    pragmaDirective(): PragmaDirectiveContext;
    importDirective(): ImportDirectiveContext;
    importAliases(): ImportAliasesContext;
    path(): PathContext;
    symbolAliases(): SymbolAliasesContext;
    contractDefinition(): ContractDefinitionContext;
    interfaceDefinition(): InterfaceDefinitionContext;
    libraryDefinition(): LibraryDefinitionContext;
    inheritanceSpecifierList(): InheritanceSpecifierListContext;
    inheritanceSpecifier(): InheritanceSpecifierContext;
    contractBodyElement(): ContractBodyElementContext;
    namedArgument(): NamedArgumentContext;
    callArgumentList(): CallArgumentListContext;
    identifierPath(): IdentifierPathContext;
    modifierInvocation(): ModifierInvocationContext;
    visibility(): VisibilityContext;
    parameterList(): ParameterListContext;
    parameterDeclaration(): ParameterDeclarationContext;
    constructorDefinition(): ConstructorDefinitionContext;
    stateMutability(): StateMutabilityContext;
    overrideSpecifier(): OverrideSpecifierContext;
    functionDefinition(): FunctionDefinitionContext;
    modifierDefinition(): ModifierDefinitionContext;
    fallbackFunctionDefinition(): FallbackFunctionDefinitionContext;
    receiveFunctionDefinition(): ReceiveFunctionDefinitionContext;
    structDefinition(): StructDefinitionContext;
    structMember(): StructMemberContext;
    enumDefinition(): EnumDefinitionContext;
    userDefinedValueTypeDefinition(): UserDefinedValueTypeDefinitionContext;
    stateVariableDeclaration(): StateVariableDeclarationContext;
    constantVariableDeclaration(): ConstantVariableDeclarationContext;
    eventParameter(): EventParameterContext;
    eventDefinition(): EventDefinitionContext;
    errorParameter(): ErrorParameterContext;
    errorDefinition(): ErrorDefinitionContext;
    userDefinableOperator(): UserDefinableOperatorContext;
    usingDirective(): UsingDirectiveContext;
    typeName(): TypeNameContext;
    typeName(_p: number): TypeNameContext;
    elementaryTypeName(allowAddressPayable: boolean): ElementaryTypeNameContext;
    functionTypeName(): FunctionTypeNameContext;
    variableDeclaration(): VariableDeclarationContext;
    dataLocation(): DataLocationContext;
    expression(): ExpressionContext;
    expression(_p: number): ExpressionContext;
    assignOp(): AssignOpContext;
    tupleExpression(): TupleExpressionContext;
    inlineArrayExpression(): InlineArrayExpressionContext;
    identifier(): IdentifierContext;
    literal(): LiteralContext;
    booleanLiteral(): BooleanLiteralContext;
    stringLiteral(): StringLiteralContext;
    hexStringLiteral(): HexStringLiteralContext;
    unicodeStringLiteral(): UnicodeStringLiteralContext;
    numberLiteral(): NumberLiteralContext;
    block(): BlockContext;
    uncheckedBlock(): UncheckedBlockContext;
    statement(): StatementContext;
    simpleStatement(): SimpleStatementContext;
    ifStatement(): IfStatementContext;
    forStatement(): ForStatementContext;
    whileStatement(): WhileStatementContext;
    doWhileStatement(): DoWhileStatementContext;
    continueStatement(): ContinueStatementContext;
    breakStatement(): BreakStatementContext;
    tryStatement(): TryStatementContext;
    catchClause(): CatchClauseContext;
    returnStatement(): ReturnStatementContext;
    emitStatement(): EmitStatementContext;
    revertStatement(): RevertStatementContext;
    assemblyStatement(): AssemblyStatementContext;
    assemblyFlags(): AssemblyFlagsContext;
    variableDeclarationList(): VariableDeclarationListContext;
    variableDeclarationTuple(): VariableDeclarationTupleContext;
    variableDeclarationStatement(): VariableDeclarationStatementContext;
    expressionStatement(): ExpressionStatementContext;
    mappingType(): MappingTypeContext;
    mappingKeyType(): MappingKeyTypeContext;
    yulStatement(): YulStatementContext;
    yulBlock(): YulBlockContext;
    yulVariableDeclaration(): YulVariableDeclarationContext;
    yulAssignment(): YulAssignmentContext;
    yulIfStatement(): YulIfStatementContext;
    yulForStatement(): YulForStatementContext;
    yulSwitchCase(): YulSwitchCaseContext;
    yulSwitchStatement(): YulSwitchStatementContext;
    yulFunctionDefinition(): YulFunctionDefinitionContext;
    yulPath(): YulPathContext;
    yulFunctionCall(): YulFunctionCallContext;
    yulBoolean(): YulBooleanContext;
    yulLiteral(): YulLiteralContext;
    yulExpression(): YulExpressionContext;
    sempred(_localctx: RuleContext, ruleIndex: number, predIndex: number): boolean;
    private constructorDefinition_sempred;
    private functionDefinition_sempred;
    private modifierDefinition_sempred;
    private fallbackFunctionDefinition_sempred;
    private receiveFunctionDefinition_sempred;
    private stateVariableDeclaration_sempred;
    private typeName_sempred;
    private elementaryTypeName_sempred;
    private functionTypeName_sempred;
    private expression_sempred;
    private static readonly _serializedATNSegments;
    private static readonly _serializedATNSegment0;
    private static readonly _serializedATNSegment1;
    private static readonly _serializedATNSegment2;
    static readonly _serializedATN: string;
    static __ATN: ATN;
    static get _ATN(): ATN;
}
export declare class SourceUnitContext extends ParserRuleContext {
    EOF(): TerminalNode;
    pragmaDirective(): PragmaDirectiveContext[];
    pragmaDirective(i: number): PragmaDirectiveContext;
    importDirective(): ImportDirectiveContext[];
    importDirective(i: number): ImportDirectiveContext;
    usingDirective(): UsingDirectiveContext[];
    usingDirective(i: number): UsingDirectiveContext;
    contractDefinition(): ContractDefinitionContext[];
    contractDefinition(i: number): ContractDefinitionContext;
    interfaceDefinition(): InterfaceDefinitionContext[];
    interfaceDefinition(i: number): InterfaceDefinitionContext;
    libraryDefinition(): LibraryDefinitionContext[];
    libraryDefinition(i: number): LibraryDefinitionContext;
    functionDefinition(): FunctionDefinitionContext[];
    functionDefinition(i: number): FunctionDefinitionContext;
    constantVariableDeclaration(): ConstantVariableDeclarationContext[];
    constantVariableDeclaration(i: number): ConstantVariableDeclarationContext;
    structDefinition(): StructDefinitionContext[];
    structDefinition(i: number): StructDefinitionContext;
    enumDefinition(): EnumDefinitionContext[];
    enumDefinition(i: number): EnumDefinitionContext;
    userDefinedValueTypeDefinition(): UserDefinedValueTypeDefinitionContext[];
    userDefinedValueTypeDefinition(i: number): UserDefinedValueTypeDefinitionContext;
    errorDefinition(): ErrorDefinitionContext[];
    errorDefinition(i: number): ErrorDefinitionContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class PragmaDirectiveContext extends ParserRuleContext {
    Pragma(): TerminalNode;
    PragmaSemicolon(): TerminalNode;
    PragmaToken(): TerminalNode[];
    PragmaToken(i: number): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class ImportDirectiveContext extends ParserRuleContext {
    _unitAlias: IdentifierContext;
    Import(): TerminalNode;
    Semicolon(): TerminalNode;
    path(): PathContext | undefined;
    symbolAliases(): SymbolAliasesContext | undefined;
    From(): TerminalNode | undefined;
    Mul(): TerminalNode | undefined;
    As(): TerminalNode | undefined;
    identifier(): IdentifierContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class ImportAliasesContext extends ParserRuleContext {
    _symbol: IdentifierContext;
    _alias: IdentifierContext;
    identifier(): IdentifierContext[];
    identifier(i: number): IdentifierContext;
    As(): TerminalNode | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class PathContext extends ParserRuleContext {
    NonEmptyStringLiteral(): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class SymbolAliasesContext extends ParserRuleContext {
    _importAliases: ImportAliasesContext;
    _aliases: ImportAliasesContext[];
    LBrace(): TerminalNode;
    RBrace(): TerminalNode;
    importAliases(): ImportAliasesContext[];
    importAliases(i: number): ImportAliasesContext;
    Comma(): TerminalNode[];
    Comma(i: number): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class ContractDefinitionContext extends ParserRuleContext {
    _name: IdentifierContext;
    Contract(): TerminalNode;
    LBrace(): TerminalNode;
    RBrace(): TerminalNode;
    identifier(): IdentifierContext;
    Abstract(): TerminalNode | undefined;
    inheritanceSpecifierList(): InheritanceSpecifierListContext | undefined;
    contractBodyElement(): ContractBodyElementContext[];
    contractBodyElement(i: number): ContractBodyElementContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class InterfaceDefinitionContext extends ParserRuleContext {
    _name: IdentifierContext;
    Interface(): TerminalNode;
    LBrace(): TerminalNode;
    RBrace(): TerminalNode;
    identifier(): IdentifierContext;
    inheritanceSpecifierList(): InheritanceSpecifierListContext | undefined;
    contractBodyElement(): ContractBodyElementContext[];
    contractBodyElement(i: number): ContractBodyElementContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class LibraryDefinitionContext extends ParserRuleContext {
    _name: IdentifierContext;
    Library(): TerminalNode;
    LBrace(): TerminalNode;
    RBrace(): TerminalNode;
    identifier(): IdentifierContext;
    contractBodyElement(): ContractBodyElementContext[];
    contractBodyElement(i: number): ContractBodyElementContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class InheritanceSpecifierListContext extends ParserRuleContext {
    _inheritanceSpecifier: InheritanceSpecifierContext;
    _inheritanceSpecifiers: InheritanceSpecifierContext[];
    Is(): TerminalNode;
    inheritanceSpecifier(): InheritanceSpecifierContext[];
    inheritanceSpecifier(i: number): InheritanceSpecifierContext;
    Comma(): TerminalNode[];
    Comma(i: number): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class InheritanceSpecifierContext extends ParserRuleContext {
    _name: IdentifierPathContext;
    _arguments: CallArgumentListContext;
    identifierPath(): IdentifierPathContext;
    callArgumentList(): CallArgumentListContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class ContractBodyElementContext extends ParserRuleContext {
    constructorDefinition(): ConstructorDefinitionContext | undefined;
    functionDefinition(): FunctionDefinitionContext | undefined;
    modifierDefinition(): ModifierDefinitionContext | undefined;
    fallbackFunctionDefinition(): FallbackFunctionDefinitionContext | undefined;
    receiveFunctionDefinition(): ReceiveFunctionDefinitionContext | undefined;
    structDefinition(): StructDefinitionContext | undefined;
    enumDefinition(): EnumDefinitionContext | undefined;
    userDefinedValueTypeDefinition(): UserDefinedValueTypeDefinitionContext | undefined;
    stateVariableDeclaration(): StateVariableDeclarationContext | undefined;
    eventDefinition(): EventDefinitionContext | undefined;
    errorDefinition(): ErrorDefinitionContext | undefined;
    usingDirective(): UsingDirectiveContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class NamedArgumentContext extends ParserRuleContext {
    _name: IdentifierContext;
    _value: ExpressionContext;
    Colon(): TerminalNode;
    identifier(): IdentifierContext;
    expression(): ExpressionContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class CallArgumentListContext extends ParserRuleContext {
    LParen(): TerminalNode;
    RParen(): TerminalNode;
    LBrace(): TerminalNode | undefined;
    RBrace(): TerminalNode | undefined;
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext;
    namedArgument(): NamedArgumentContext[];
    namedArgument(i: number): NamedArgumentContext;
    Comma(): TerminalNode[];
    Comma(i: number): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class IdentifierPathContext extends ParserRuleContext {
    identifier(): IdentifierContext[];
    identifier(i: number): IdentifierContext;
    Period(): TerminalNode[];
    Period(i: number): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class ModifierInvocationContext extends ParserRuleContext {
    identifierPath(): IdentifierPathContext;
    callArgumentList(): CallArgumentListContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class VisibilityContext extends ParserRuleContext {
    Internal(): TerminalNode | undefined;
    External(): TerminalNode | undefined;
    Private(): TerminalNode | undefined;
    Public(): TerminalNode | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class ParameterListContext extends ParserRuleContext {
    _parameterDeclaration: ParameterDeclarationContext;
    _parameters: ParameterDeclarationContext[];
    parameterDeclaration(): ParameterDeclarationContext[];
    parameterDeclaration(i: number): ParameterDeclarationContext;
    Comma(): TerminalNode[];
    Comma(i: number): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class ParameterDeclarationContext extends ParserRuleContext {
    _type: TypeNameContext;
    _location: DataLocationContext;
    _name: IdentifierContext;
    typeName(): TypeNameContext;
    dataLocation(): DataLocationContext | undefined;
    identifier(): IdentifierContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class ConstructorDefinitionContext extends ParserRuleContext {
    payableSet: boolean;
    visibilitySet: boolean;
    _arguments: ParameterListContext;
    _body: BlockContext;
    Constructor(): TerminalNode;
    LParen(): TerminalNode;
    RParen(): TerminalNode;
    block(): BlockContext;
    modifierInvocation(): ModifierInvocationContext[];
    modifierInvocation(i: number): ModifierInvocationContext;
    Payable(): TerminalNode[];
    Payable(i: number): TerminalNode;
    Internal(): TerminalNode[];
    Internal(i: number): TerminalNode;
    Public(): TerminalNode[];
    Public(i: number): TerminalNode;
    parameterList(): ParameterListContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class StateMutabilityContext extends ParserRuleContext {
    Pure(): TerminalNode | undefined;
    View(): TerminalNode | undefined;
    Payable(): TerminalNode | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class OverrideSpecifierContext extends ParserRuleContext {
    _identifierPath: IdentifierPathContext;
    _overrides: IdentifierPathContext[];
    Override(): TerminalNode;
    LParen(): TerminalNode | undefined;
    RParen(): TerminalNode | undefined;
    identifierPath(): IdentifierPathContext[];
    identifierPath(i: number): IdentifierPathContext;
    Comma(): TerminalNode[];
    Comma(i: number): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class FunctionDefinitionContext extends ParserRuleContext {
    visibilitySet: boolean;
    mutabilitySet: boolean;
    virtualSet: boolean;
    overrideSpecifierSet: boolean;
    _arguments: ParameterListContext;
    _returnParameters: ParameterListContext;
    _body: BlockContext;
    Function(): TerminalNode;
    LParen(): TerminalNode[];
    LParen(i: number): TerminalNode;
    RParen(): TerminalNode[];
    RParen(i: number): TerminalNode;
    identifier(): IdentifierContext | undefined;
    Fallback(): TerminalNode | undefined;
    Receive(): TerminalNode | undefined;
    Semicolon(): TerminalNode | undefined;
    visibility(): VisibilityContext[];
    visibility(i: number): VisibilityContext;
    stateMutability(): StateMutabilityContext[];
    stateMutability(i: number): StateMutabilityContext;
    modifierInvocation(): ModifierInvocationContext[];
    modifierInvocation(i: number): ModifierInvocationContext;
    Virtual(): TerminalNode[];
    Virtual(i: number): TerminalNode;
    overrideSpecifier(): OverrideSpecifierContext[];
    overrideSpecifier(i: number): OverrideSpecifierContext;
    Returns(): TerminalNode | undefined;
    block(): BlockContext | undefined;
    parameterList(): ParameterListContext[];
    parameterList(i: number): ParameterListContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class ModifierDefinitionContext extends ParserRuleContext {
    virtualSet: boolean;
    overrideSpecifierSet: boolean;
    _name: IdentifierContext;
    _arguments: ParameterListContext;
    _body: BlockContext;
    Modifier(): TerminalNode;
    identifier(): IdentifierContext;
    Semicolon(): TerminalNode | undefined;
    LParen(): TerminalNode | undefined;
    RParen(): TerminalNode | undefined;
    Virtual(): TerminalNode[];
    Virtual(i: number): TerminalNode;
    overrideSpecifier(): OverrideSpecifierContext[];
    overrideSpecifier(i: number): OverrideSpecifierContext;
    block(): BlockContext | undefined;
    parameterList(): ParameterListContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class FallbackFunctionDefinitionContext extends ParserRuleContext {
    visibilitySet: boolean;
    mutabilitySet: boolean;
    virtualSet: boolean;
    overrideSpecifierSet: boolean;
    hasParameters: boolean;
    _kind: Token;
    _returnParameters: ParameterListContext;
    _body: BlockContext;
    LParen(): TerminalNode[];
    LParen(i: number): TerminalNode;
    RParen(): TerminalNode[];
    RParen(i: number): TerminalNode;
    Fallback(): TerminalNode;
    Returns(): TerminalNode | undefined;
    Semicolon(): TerminalNode | undefined;
    parameterList(): ParameterListContext[];
    parameterList(i: number): ParameterListContext;
    External(): TerminalNode[];
    External(i: number): TerminalNode;
    stateMutability(): StateMutabilityContext[];
    stateMutability(i: number): StateMutabilityContext;
    modifierInvocation(): ModifierInvocationContext[];
    modifierInvocation(i: number): ModifierInvocationContext;
    Virtual(): TerminalNode[];
    Virtual(i: number): TerminalNode;
    overrideSpecifier(): OverrideSpecifierContext[];
    overrideSpecifier(i: number): OverrideSpecifierContext;
    block(): BlockContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class ReceiveFunctionDefinitionContext extends ParserRuleContext {
    visibilitySet: boolean;
    mutabilitySet: boolean;
    virtualSet: boolean;
    overrideSpecifierSet: boolean;
    _kind: Token;
    _body: BlockContext;
    LParen(): TerminalNode;
    RParen(): TerminalNode;
    Receive(): TerminalNode;
    Semicolon(): TerminalNode | undefined;
    External(): TerminalNode[];
    External(i: number): TerminalNode;
    Payable(): TerminalNode[];
    Payable(i: number): TerminalNode;
    modifierInvocation(): ModifierInvocationContext[];
    modifierInvocation(i: number): ModifierInvocationContext;
    Virtual(): TerminalNode[];
    Virtual(i: number): TerminalNode;
    overrideSpecifier(): OverrideSpecifierContext[];
    overrideSpecifier(i: number): OverrideSpecifierContext;
    block(): BlockContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class StructDefinitionContext extends ParserRuleContext {
    _name: IdentifierContext;
    _members: StructMemberContext;
    Struct(): TerminalNode;
    LBrace(): TerminalNode;
    RBrace(): TerminalNode;
    identifier(): IdentifierContext;
    structMember(): StructMemberContext[];
    structMember(i: number): StructMemberContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class StructMemberContext extends ParserRuleContext {
    _type: TypeNameContext;
    _name: IdentifierContext;
    Semicolon(): TerminalNode;
    typeName(): TypeNameContext;
    identifier(): IdentifierContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class EnumDefinitionContext extends ParserRuleContext {
    _name: IdentifierContext;
    _identifier: IdentifierContext;
    _enumValues: IdentifierContext[];
    Enum(): TerminalNode;
    LBrace(): TerminalNode;
    RBrace(): TerminalNode;
    identifier(): IdentifierContext[];
    identifier(i: number): IdentifierContext;
    Comma(): TerminalNode[];
    Comma(i: number): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class UserDefinedValueTypeDefinitionContext extends ParserRuleContext {
    _name: IdentifierContext;
    Type(): TerminalNode;
    Is(): TerminalNode;
    elementaryTypeName(): ElementaryTypeNameContext;
    Semicolon(): TerminalNode;
    identifier(): IdentifierContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class StateVariableDeclarationContext extends ParserRuleContext {
    constantnessSet: boolean;
    visibilitySet: boolean;
    overrideSpecifierSet: boolean;
    _type: TypeNameContext;
    _name: IdentifierContext;
    _initialValue: ExpressionContext;
    Semicolon(): TerminalNode;
    typeName(): TypeNameContext;
    identifier(): IdentifierContext;
    Public(): TerminalNode[];
    Public(i: number): TerminalNode;
    Private(): TerminalNode[];
    Private(i: number): TerminalNode;
    Internal(): TerminalNode[];
    Internal(i: number): TerminalNode;
    Constant(): TerminalNode[];
    Constant(i: number): TerminalNode;
    overrideSpecifier(): OverrideSpecifierContext[];
    overrideSpecifier(i: number): OverrideSpecifierContext;
    Immutable(): TerminalNode[];
    Immutable(i: number): TerminalNode;
    Assign(): TerminalNode | undefined;
    expression(): ExpressionContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class ConstantVariableDeclarationContext extends ParserRuleContext {
    _type: TypeNameContext;
    _name: IdentifierContext;
    _initialValue: ExpressionContext;
    Constant(): TerminalNode;
    Assign(): TerminalNode;
    Semicolon(): TerminalNode;
    typeName(): TypeNameContext;
    identifier(): IdentifierContext;
    expression(): ExpressionContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class EventParameterContext extends ParserRuleContext {
    _type: TypeNameContext;
    _name: IdentifierContext;
    typeName(): TypeNameContext;
    Indexed(): TerminalNode | undefined;
    identifier(): IdentifierContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class EventDefinitionContext extends ParserRuleContext {
    _name: IdentifierContext;
    _eventParameter: EventParameterContext;
    _parameters: EventParameterContext[];
    Event(): TerminalNode;
    LParen(): TerminalNode;
    RParen(): TerminalNode;
    Semicolon(): TerminalNode;
    identifier(): IdentifierContext;
    Anonymous(): TerminalNode | undefined;
    eventParameter(): EventParameterContext[];
    eventParameter(i: number): EventParameterContext;
    Comma(): TerminalNode[];
    Comma(i: number): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class ErrorParameterContext extends ParserRuleContext {
    _type: TypeNameContext;
    _name: IdentifierContext;
    typeName(): TypeNameContext;
    identifier(): IdentifierContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class ErrorDefinitionContext extends ParserRuleContext {
    _name: IdentifierContext;
    _errorParameter: ErrorParameterContext;
    _parameters: ErrorParameterContext[];
    Error(): TerminalNode;
    LParen(): TerminalNode;
    RParen(): TerminalNode;
    Semicolon(): TerminalNode;
    identifier(): IdentifierContext;
    errorParameter(): ErrorParameterContext[];
    errorParameter(i: number): ErrorParameterContext;
    Comma(): TerminalNode[];
    Comma(i: number): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class UserDefinableOperatorContext extends ParserRuleContext {
    BitAnd(): TerminalNode | undefined;
    BitNot(): TerminalNode | undefined;
    BitOr(): TerminalNode | undefined;
    BitXor(): TerminalNode | undefined;
    Add(): TerminalNode | undefined;
    Div(): TerminalNode | undefined;
    Mod(): TerminalNode | undefined;
    Mul(): TerminalNode | undefined;
    Sub(): TerminalNode | undefined;
    Equal(): TerminalNode | undefined;
    GreaterThan(): TerminalNode | undefined;
    GreaterThanOrEqual(): TerminalNode | undefined;
    LessThan(): TerminalNode | undefined;
    LessThanOrEqual(): TerminalNode | undefined;
    NotEqual(): TerminalNode | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class UsingDirectiveContext extends ParserRuleContext {
    Using(): TerminalNode;
    For(): TerminalNode;
    Semicolon(): TerminalNode;
    identifierPath(): IdentifierPathContext[];
    identifierPath(i: number): IdentifierPathContext;
    Mul(): TerminalNode | undefined;
    typeName(): TypeNameContext | undefined;
    Global(): TerminalNode | undefined;
    LBrace(): TerminalNode | undefined;
    RBrace(): TerminalNode | undefined;
    As(): TerminalNode[];
    As(i: number): TerminalNode;
    userDefinableOperator(): UserDefinableOperatorContext[];
    userDefinableOperator(i: number): UserDefinableOperatorContext;
    Comma(): TerminalNode[];
    Comma(i: number): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class TypeNameContext extends ParserRuleContext {
    elementaryTypeName(): ElementaryTypeNameContext | undefined;
    functionTypeName(): FunctionTypeNameContext | undefined;
    mappingType(): MappingTypeContext | undefined;
    identifierPath(): IdentifierPathContext | undefined;
    typeName(): TypeNameContext | undefined;
    LBrack(): TerminalNode | undefined;
    RBrack(): TerminalNode | undefined;
    expression(): ExpressionContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class ElementaryTypeNameContext extends ParserRuleContext {
    allowAddressPayable: boolean;
    Address(): TerminalNode | undefined;
    Payable(): TerminalNode | undefined;
    Bool(): TerminalNode | undefined;
    String(): TerminalNode | undefined;
    Bytes(): TerminalNode | undefined;
    SignedIntegerType(): TerminalNode | undefined;
    UnsignedIntegerType(): TerminalNode | undefined;
    FixedBytes(): TerminalNode | undefined;
    Fixed(): TerminalNode | undefined;
    Ufixed(): TerminalNode | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number, allowAddressPayable: boolean);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class FunctionTypeNameContext extends ParserRuleContext {
    visibilitySet: boolean;
    mutabilitySet: boolean;
    _arguments: ParameterListContext;
    _returnParameters: ParameterListContext;
    Function(): TerminalNode;
    LParen(): TerminalNode[];
    LParen(i: number): TerminalNode;
    RParen(): TerminalNode[];
    RParen(i: number): TerminalNode;
    visibility(): VisibilityContext[];
    visibility(i: number): VisibilityContext;
    stateMutability(): StateMutabilityContext[];
    stateMutability(i: number): StateMutabilityContext;
    Returns(): TerminalNode | undefined;
    parameterList(): ParameterListContext[];
    parameterList(i: number): ParameterListContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class VariableDeclarationContext extends ParserRuleContext {
    _type: TypeNameContext;
    _location: DataLocationContext;
    _name: IdentifierContext;
    typeName(): TypeNameContext;
    identifier(): IdentifierContext;
    dataLocation(): DataLocationContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class DataLocationContext extends ParserRuleContext {
    Memory(): TerminalNode | undefined;
    Storage(): TerminalNode | undefined;
    Calldata(): TerminalNode | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class ExpressionContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    copyFrom(ctx: ExpressionContext): void;
}
export declare class IndexAccessContext extends ExpressionContext {
    _index: ExpressionContext;
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext;
    LBrack(): TerminalNode;
    RBrack(): TerminalNode;
    constructor(ctx: ExpressionContext);
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class IndexRangeAccessContext extends ExpressionContext {
    _start: ExpressionContext;
    _end: ExpressionContext;
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext;
    LBrack(): TerminalNode;
    Colon(): TerminalNode;
    RBrack(): TerminalNode;
    constructor(ctx: ExpressionContext);
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class MemberAccessContext extends ExpressionContext {
    expression(): ExpressionContext;
    Period(): TerminalNode;
    identifier(): IdentifierContext | undefined;
    Address(): TerminalNode | undefined;
    constructor(ctx: ExpressionContext);
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class FunctionCallOptionsContext extends ExpressionContext {
    expression(): ExpressionContext;
    LBrace(): TerminalNode;
    RBrace(): TerminalNode;
    namedArgument(): NamedArgumentContext[];
    namedArgument(i: number): NamedArgumentContext;
    Comma(): TerminalNode[];
    Comma(i: number): TerminalNode;
    constructor(ctx: ExpressionContext);
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class FunctionCallContext extends ExpressionContext {
    expression(): ExpressionContext;
    callArgumentList(): CallArgumentListContext;
    constructor(ctx: ExpressionContext);
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class PayableConversionContext extends ExpressionContext {
    Payable(): TerminalNode;
    callArgumentList(): CallArgumentListContext;
    constructor(ctx: ExpressionContext);
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class MetaTypeContext extends ExpressionContext {
    Type(): TerminalNode;
    LParen(): TerminalNode;
    typeName(): TypeNameContext;
    RParen(): TerminalNode;
    constructor(ctx: ExpressionContext);
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class UnaryPrefixOperationContext extends ExpressionContext {
    expression(): ExpressionContext;
    Inc(): TerminalNode | undefined;
    Dec(): TerminalNode | undefined;
    Not(): TerminalNode | undefined;
    BitNot(): TerminalNode | undefined;
    Delete(): TerminalNode | undefined;
    Sub(): TerminalNode | undefined;
    constructor(ctx: ExpressionContext);
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class UnarySuffixOperationContext extends ExpressionContext {
    expression(): ExpressionContext;
    Inc(): TerminalNode | undefined;
    Dec(): TerminalNode | undefined;
    constructor(ctx: ExpressionContext);
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class ExpOperationContext extends ExpressionContext {
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext;
    Exp(): TerminalNode;
    constructor(ctx: ExpressionContext);
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class MulDivModOperationContext extends ExpressionContext {
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext;
    Mul(): TerminalNode | undefined;
    Div(): TerminalNode | undefined;
    Mod(): TerminalNode | undefined;
    constructor(ctx: ExpressionContext);
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class AddSubOperationContext extends ExpressionContext {
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext;
    Add(): TerminalNode | undefined;
    Sub(): TerminalNode | undefined;
    constructor(ctx: ExpressionContext);
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class ShiftOperationContext extends ExpressionContext {
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext;
    Shl(): TerminalNode | undefined;
    Sar(): TerminalNode | undefined;
    Shr(): TerminalNode | undefined;
    constructor(ctx: ExpressionContext);
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class BitAndOperationContext extends ExpressionContext {
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext;
    BitAnd(): TerminalNode;
    constructor(ctx: ExpressionContext);
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class BitXorOperationContext extends ExpressionContext {
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext;
    BitXor(): TerminalNode;
    constructor(ctx: ExpressionContext);
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class BitOrOperationContext extends ExpressionContext {
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext;
    BitOr(): TerminalNode;
    constructor(ctx: ExpressionContext);
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class OrderComparisonContext extends ExpressionContext {
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext;
    LessThan(): TerminalNode | undefined;
    GreaterThan(): TerminalNode | undefined;
    LessThanOrEqual(): TerminalNode | undefined;
    GreaterThanOrEqual(): TerminalNode | undefined;
    constructor(ctx: ExpressionContext);
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class EqualityComparisonContext extends ExpressionContext {
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext;
    Equal(): TerminalNode | undefined;
    NotEqual(): TerminalNode | undefined;
    constructor(ctx: ExpressionContext);
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class AndOperationContext extends ExpressionContext {
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext;
    And(): TerminalNode;
    constructor(ctx: ExpressionContext);
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class OrOperationContext extends ExpressionContext {
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext;
    Or(): TerminalNode;
    constructor(ctx: ExpressionContext);
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class ConditionalContext extends ExpressionContext {
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext;
    Conditional(): TerminalNode;
    Colon(): TerminalNode;
    constructor(ctx: ExpressionContext);
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class AssignmentContext extends ExpressionContext {
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext;
    assignOp(): AssignOpContext;
    constructor(ctx: ExpressionContext);
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class NewExpressionContext extends ExpressionContext {
    New(): TerminalNode;
    typeName(): TypeNameContext;
    constructor(ctx: ExpressionContext);
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class TupleContext extends ExpressionContext {
    tupleExpression(): TupleExpressionContext;
    constructor(ctx: ExpressionContext);
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class InlineArrayContext extends ExpressionContext {
    inlineArrayExpression(): InlineArrayExpressionContext;
    constructor(ctx: ExpressionContext);
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class PrimaryExpressionContext extends ExpressionContext {
    identifier(): IdentifierContext | undefined;
    literal(): LiteralContext | undefined;
    elementaryTypeName(): ElementaryTypeNameContext | undefined;
    constructor(ctx: ExpressionContext);
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class AssignOpContext extends ParserRuleContext {
    Assign(): TerminalNode | undefined;
    AssignBitOr(): TerminalNode | undefined;
    AssignBitXor(): TerminalNode | undefined;
    AssignBitAnd(): TerminalNode | undefined;
    AssignShl(): TerminalNode | undefined;
    AssignSar(): TerminalNode | undefined;
    AssignShr(): TerminalNode | undefined;
    AssignAdd(): TerminalNode | undefined;
    AssignSub(): TerminalNode | undefined;
    AssignMul(): TerminalNode | undefined;
    AssignDiv(): TerminalNode | undefined;
    AssignMod(): TerminalNode | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class TupleExpressionContext extends ParserRuleContext {
    LParen(): TerminalNode;
    RParen(): TerminalNode;
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext;
    Comma(): TerminalNode[];
    Comma(i: number): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class InlineArrayExpressionContext extends ParserRuleContext {
    LBrack(): TerminalNode;
    RBrack(): TerminalNode;
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext;
    Comma(): TerminalNode[];
    Comma(i: number): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class IdentifierContext extends ParserRuleContext {
    Identifier(): TerminalNode | undefined;
    From(): TerminalNode | undefined;
    Error(): TerminalNode | undefined;
    Revert(): TerminalNode | undefined;
    Global(): TerminalNode | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class LiteralContext extends ParserRuleContext {
    stringLiteral(): StringLiteralContext | undefined;
    numberLiteral(): NumberLiteralContext | undefined;
    booleanLiteral(): BooleanLiteralContext | undefined;
    hexStringLiteral(): HexStringLiteralContext | undefined;
    unicodeStringLiteral(): UnicodeStringLiteralContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class BooleanLiteralContext extends ParserRuleContext {
    True(): TerminalNode | undefined;
    False(): TerminalNode | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class StringLiteralContext extends ParserRuleContext {
    NonEmptyStringLiteral(): TerminalNode[];
    NonEmptyStringLiteral(i: number): TerminalNode;
    EmptyStringLiteral(): TerminalNode[];
    EmptyStringLiteral(i: number): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class HexStringLiteralContext extends ParserRuleContext {
    HexString(): TerminalNode[];
    HexString(i: number): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class UnicodeStringLiteralContext extends ParserRuleContext {
    UnicodeStringLiteral(): TerminalNode[];
    UnicodeStringLiteral(i: number): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class NumberLiteralContext extends ParserRuleContext {
    DecimalNumber(): TerminalNode | undefined;
    HexNumber(): TerminalNode | undefined;
    NumberUnit(): TerminalNode | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class BlockContext extends ParserRuleContext {
    LBrace(): TerminalNode;
    RBrace(): TerminalNode;
    statement(): StatementContext[];
    statement(i: number): StatementContext;
    uncheckedBlock(): UncheckedBlockContext[];
    uncheckedBlock(i: number): UncheckedBlockContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class UncheckedBlockContext extends ParserRuleContext {
    Unchecked(): TerminalNode;
    block(): BlockContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class StatementContext extends ParserRuleContext {
    block(): BlockContext | undefined;
    simpleStatement(): SimpleStatementContext | undefined;
    ifStatement(): IfStatementContext | undefined;
    forStatement(): ForStatementContext | undefined;
    whileStatement(): WhileStatementContext | undefined;
    doWhileStatement(): DoWhileStatementContext | undefined;
    continueStatement(): ContinueStatementContext | undefined;
    breakStatement(): BreakStatementContext | undefined;
    tryStatement(): TryStatementContext | undefined;
    returnStatement(): ReturnStatementContext | undefined;
    emitStatement(): EmitStatementContext | undefined;
    revertStatement(): RevertStatementContext | undefined;
    assemblyStatement(): AssemblyStatementContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class SimpleStatementContext extends ParserRuleContext {
    variableDeclarationStatement(): VariableDeclarationStatementContext | undefined;
    expressionStatement(): ExpressionStatementContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class IfStatementContext extends ParserRuleContext {
    If(): TerminalNode;
    LParen(): TerminalNode;
    expression(): ExpressionContext;
    RParen(): TerminalNode;
    statement(): StatementContext[];
    statement(i: number): StatementContext;
    Else(): TerminalNode | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class ForStatementContext extends ParserRuleContext {
    For(): TerminalNode;
    LParen(): TerminalNode;
    RParen(): TerminalNode;
    statement(): StatementContext;
    simpleStatement(): SimpleStatementContext | undefined;
    Semicolon(): TerminalNode[];
    Semicolon(i: number): TerminalNode;
    expressionStatement(): ExpressionStatementContext | undefined;
    expression(): ExpressionContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class WhileStatementContext extends ParserRuleContext {
    While(): TerminalNode;
    LParen(): TerminalNode;
    expression(): ExpressionContext;
    RParen(): TerminalNode;
    statement(): StatementContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class DoWhileStatementContext extends ParserRuleContext {
    Do(): TerminalNode;
    statement(): StatementContext;
    While(): TerminalNode;
    LParen(): TerminalNode;
    expression(): ExpressionContext;
    RParen(): TerminalNode;
    Semicolon(): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class ContinueStatementContext extends ParserRuleContext {
    Continue(): TerminalNode;
    Semicolon(): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class BreakStatementContext extends ParserRuleContext {
    Break(): TerminalNode;
    Semicolon(): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class TryStatementContext extends ParserRuleContext {
    _returnParameters: ParameterListContext;
    Try(): TerminalNode;
    expression(): ExpressionContext;
    block(): BlockContext;
    Returns(): TerminalNode | undefined;
    LParen(): TerminalNode | undefined;
    RParen(): TerminalNode | undefined;
    catchClause(): CatchClauseContext[];
    catchClause(i: number): CatchClauseContext;
    parameterList(): ParameterListContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class CatchClauseContext extends ParserRuleContext {
    _arguments: ParameterListContext;
    Catch(): TerminalNode;
    block(): BlockContext;
    LParen(): TerminalNode | undefined;
    RParen(): TerminalNode | undefined;
    identifier(): IdentifierContext | undefined;
    parameterList(): ParameterListContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class ReturnStatementContext extends ParserRuleContext {
    Return(): TerminalNode;
    Semicolon(): TerminalNode;
    expression(): ExpressionContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class EmitStatementContext extends ParserRuleContext {
    Emit(): TerminalNode;
    expression(): ExpressionContext;
    callArgumentList(): CallArgumentListContext;
    Semicolon(): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class RevertStatementContext extends ParserRuleContext {
    Revert(): TerminalNode;
    expression(): ExpressionContext;
    callArgumentList(): CallArgumentListContext;
    Semicolon(): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class AssemblyStatementContext extends ParserRuleContext {
    Assembly(): TerminalNode;
    AssemblyLBrace(): TerminalNode;
    YulRBrace(): TerminalNode;
    AssemblyDialect(): TerminalNode | undefined;
    assemblyFlags(): AssemblyFlagsContext | undefined;
    yulStatement(): YulStatementContext[];
    yulStatement(i: number): YulStatementContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class AssemblyFlagsContext extends ParserRuleContext {
    AssemblyBlockLParen(): TerminalNode;
    AssemblyFlagString(): TerminalNode[];
    AssemblyFlagString(i: number): TerminalNode;
    AssemblyBlockRParen(): TerminalNode;
    AssemblyBlockComma(): TerminalNode[];
    AssemblyBlockComma(i: number): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class VariableDeclarationListContext extends ParserRuleContext {
    _variableDeclaration: VariableDeclarationContext;
    _variableDeclarations: VariableDeclarationContext[];
    variableDeclaration(): VariableDeclarationContext[];
    variableDeclaration(i: number): VariableDeclarationContext;
    Comma(): TerminalNode[];
    Comma(i: number): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class VariableDeclarationTupleContext extends ParserRuleContext {
    _variableDeclaration: VariableDeclarationContext;
    _variableDeclarations: VariableDeclarationContext[];
    LParen(): TerminalNode;
    RParen(): TerminalNode;
    variableDeclaration(): VariableDeclarationContext[];
    variableDeclaration(i: number): VariableDeclarationContext;
    Comma(): TerminalNode[];
    Comma(i: number): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class VariableDeclarationStatementContext extends ParserRuleContext {
    Semicolon(): TerminalNode;
    variableDeclaration(): VariableDeclarationContext | undefined;
    variableDeclarationTuple(): VariableDeclarationTupleContext | undefined;
    Assign(): TerminalNode | undefined;
    expression(): ExpressionContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class ExpressionStatementContext extends ParserRuleContext {
    expression(): ExpressionContext;
    Semicolon(): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class MappingTypeContext extends ParserRuleContext {
    _key: MappingKeyTypeContext;
    _name: IdentifierContext;
    _value: TypeNameContext;
    Mapping(): TerminalNode;
    LParen(): TerminalNode;
    DoubleArrow(): TerminalNode;
    RParen(): TerminalNode;
    mappingKeyType(): MappingKeyTypeContext;
    typeName(): TypeNameContext;
    identifier(): IdentifierContext[];
    identifier(i: number): IdentifierContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class MappingKeyTypeContext extends ParserRuleContext {
    elementaryTypeName(): ElementaryTypeNameContext | undefined;
    identifierPath(): IdentifierPathContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class YulStatementContext extends ParserRuleContext {
    yulBlock(): YulBlockContext | undefined;
    yulVariableDeclaration(): YulVariableDeclarationContext | undefined;
    yulAssignment(): YulAssignmentContext | undefined;
    yulFunctionCall(): YulFunctionCallContext | undefined;
    yulIfStatement(): YulIfStatementContext | undefined;
    yulForStatement(): YulForStatementContext | undefined;
    yulSwitchStatement(): YulSwitchStatementContext | undefined;
    YulLeave(): TerminalNode | undefined;
    YulBreak(): TerminalNode | undefined;
    YulContinue(): TerminalNode | undefined;
    yulFunctionDefinition(): YulFunctionDefinitionContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class YulBlockContext extends ParserRuleContext {
    YulLBrace(): TerminalNode;
    YulRBrace(): TerminalNode;
    yulStatement(): YulStatementContext[];
    yulStatement(i: number): YulStatementContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class YulVariableDeclarationContext extends ParserRuleContext {
    _YulIdentifier: Token;
    _variables: Token[];
    YulLet(): TerminalNode | undefined;
    YulIdentifier(): TerminalNode[];
    YulIdentifier(i: number): TerminalNode;
    YulAssign(): TerminalNode | undefined;
    yulExpression(): YulExpressionContext | undefined;
    YulComma(): TerminalNode[];
    YulComma(i: number): TerminalNode;
    yulFunctionCall(): YulFunctionCallContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class YulAssignmentContext extends ParserRuleContext {
    yulPath(): YulPathContext[];
    yulPath(i: number): YulPathContext;
    YulAssign(): TerminalNode;
    yulExpression(): YulExpressionContext | undefined;
    yulFunctionCall(): YulFunctionCallContext | undefined;
    YulComma(): TerminalNode[];
    YulComma(i: number): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class YulIfStatementContext extends ParserRuleContext {
    _cond: YulExpressionContext;
    _body: YulBlockContext;
    YulIf(): TerminalNode;
    yulExpression(): YulExpressionContext;
    yulBlock(): YulBlockContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class YulForStatementContext extends ParserRuleContext {
    _init: YulBlockContext;
    _cond: YulExpressionContext;
    _post: YulBlockContext;
    _body: YulBlockContext;
    YulFor(): TerminalNode;
    yulBlock(): YulBlockContext[];
    yulBlock(i: number): YulBlockContext;
    yulExpression(): YulExpressionContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class YulSwitchCaseContext extends ParserRuleContext {
    YulCase(): TerminalNode;
    yulLiteral(): YulLiteralContext;
    yulBlock(): YulBlockContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class YulSwitchStatementContext extends ParserRuleContext {
    YulSwitch(): TerminalNode;
    yulExpression(): YulExpressionContext;
    YulDefault(): TerminalNode | undefined;
    yulBlock(): YulBlockContext | undefined;
    yulSwitchCase(): YulSwitchCaseContext[];
    yulSwitchCase(i: number): YulSwitchCaseContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class YulFunctionDefinitionContext extends ParserRuleContext {
    _YulIdentifier: Token;
    _arguments: Token[];
    _returnParameters: Token[];
    _body: YulBlockContext;
    YulFunction(): TerminalNode;
    YulIdentifier(): TerminalNode[];
    YulIdentifier(i: number): TerminalNode;
    YulLParen(): TerminalNode;
    YulRParen(): TerminalNode;
    yulBlock(): YulBlockContext;
    YulArrow(): TerminalNode | undefined;
    YulComma(): TerminalNode[];
    YulComma(i: number): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class YulPathContext extends ParserRuleContext {
    YulIdentifier(): TerminalNode[];
    YulIdentifier(i: number): TerminalNode;
    YulPeriod(): TerminalNode[];
    YulPeriod(i: number): TerminalNode;
    YulEVMBuiltin(): TerminalNode[];
    YulEVMBuiltin(i: number): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class YulFunctionCallContext extends ParserRuleContext {
    YulLParen(): TerminalNode;
    YulRParen(): TerminalNode;
    YulIdentifier(): TerminalNode | undefined;
    YulEVMBuiltin(): TerminalNode | undefined;
    yulExpression(): YulExpressionContext[];
    yulExpression(i: number): YulExpressionContext;
    YulComma(): TerminalNode[];
    YulComma(i: number): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class YulBooleanContext extends ParserRuleContext {
    YulTrue(): TerminalNode | undefined;
    YulFalse(): TerminalNode | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class YulLiteralContext extends ParserRuleContext {
    YulDecimalNumber(): TerminalNode | undefined;
    YulStringLiteral(): TerminalNode | undefined;
    YulHexNumber(): TerminalNode | undefined;
    yulBoolean(): YulBooleanContext | undefined;
    YulHexStringLiteral(): TerminalNode | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
export declare class YulExpressionContext extends ParserRuleContext {
    yulPath(): YulPathContext | undefined;
    yulFunctionCall(): YulFunctionCallContext | undefined;
    yulLiteral(): YulLiteralContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    get ruleIndex(): number;
    enterRule(listener: SolidityParserListener): void;
    exitRule(listener: SolidityParserListener): void;
    accept<Result>(visitor: SolidityParserVisitor<Result>): Result;
}
