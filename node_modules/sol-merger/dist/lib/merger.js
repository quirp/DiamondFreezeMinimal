"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _Merger_pluginsRegistry, _Merger_additionalRoots, _Merger_fileRoots;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Merger = void 0;
const debug_1 = __importDefault(require("debug"));
const path_1 = __importDefault(require("path"));
const fs_1 = require("fs");
const fileAnalyzer_1 = require("./fileAnalyzer");
const importRegistry_1 = require("./importRegistry");
const importsAnalyzer_1 = require("./importsAnalyzer");
const types_1 = require("./types");
const utils_1 = require("./utils");
const pluginsRegistry_1 = require("./pluginsRegistry");
const error = (0, debug_1.default)('sol-merger:error');
const debug = (0, debug_1.default)('sol-merger:debug');
class Merger {
    constructor(options = {}) {
        var _a;
        this.options = options;
        this.delimeter = this.options.delimeter || '\n\n';
        this.commentsDelimeter = this.options.commentsDelimeter || '\n';
        _Merger_pluginsRegistry.set(this, void 0);
        this.nodeModulesRoot = '';
        _Merger_additionalRoots.set(this, void 0);
        _Merger_fileRoots.set(this, void 0);
        if ('removeComments' in options) {
            this.removeComments = options.removeComments;
        }
        else {
            this.removeComments = false;
        }
        this.importRegistry = new importRegistry_1.ImportsRegistry();
        const exportPlugins = options.exportPlugins || [];
        __classPrivateFieldSet(this, _Merger_pluginsRegistry, new pluginsRegistry_1.ExportPluginsRegistry(exportPlugins), "f");
        __classPrivateFieldSet(this, _Merger_additionalRoots, (_a = options.additionalRoots) !== null && _a !== void 0 ? _a : [], "f");
    }
    getPragmaRegex() {
        return /(pragma ([a-zA-Z_$][a-zA-Z_$0-9]*) (.+?);)/g;
    }
    getImportRegex() {
        return /import.+?;/g;
    }
    getPragma(contents) {
        let result = '';
        const pragmaRegex = this.getPragmaRegex();
        let group = pragmaRegex.exec(contents);
        while (group) {
            result += group[1] + '\n';
            group = pragmaRegex.exec(contents);
        }
        return result;
    }
    stripPragma(contents) {
        return contents.replace(this.getPragmaRegex(), '').trim();
    }
    init(file) {
        return __awaiter(this, void 0, void 0, function* () {
            this.importRegistry = new importRegistry_1.ImportsRegistry();
            this.nodeModulesRoot = yield this.getNodeModulesPath(file);
            __classPrivateFieldSet(this, _Merger_fileRoots, [this.nodeModulesRoot, ...__classPrivateFieldGet(this, _Merger_additionalRoots, "f")], "f");
        });
    }
    processFile(file, isRoot, parentImport) {
        return __awaiter(this, void 0, void 0, function* () {
            if (isRoot) {
                yield this.init(file);
            }
            if (this.importRegistry.isImportProcessed(parentImport === null || parentImport === void 0 ? void 0 : parentImport.importStatement)) {
                debug('  %s Import statement already processed: %s', '⚠', parentImport === null || parentImport === void 0 ? void 0 : parentImport.importStatement);
                return '';
            }
            if (parentImport) {
                this.importRegistry.registerImportStatement(parentImport.importStatement);
            }
            debug('Processing file %s', file);
            const analyzedFile = yield new fileAnalyzer_1.FileAnalyzer(file, this.removeComments).analyze();
            return this.buildString(analyzedFile, isRoot, parentImport);
        });
    }
    buildString(analyzedFile, isRoot, parentImport) {
        return __awaiter(this, void 0, void 0, function* () {
            let result = '';
            if (isRoot) {
                const pragma = this.getPragma(analyzedFile.contents);
                result = pragma + this.delimeter;
            }
            const imports = yield this.processImports(analyzedFile);
            for (const i of imports) {
                result += i + this.delimeter;
            }
            const fileExports = yield this.processExports(analyzedFile, parentImport);
            for (const e of fileExports) {
                if (this.isComment(e)) {
                    result += e + this.commentsDelimeter;
                }
                else {
                    result += e + this.delimeter;
                }
            }
            return result.trimRight();
        });
    }
    processImports(analyzedFile) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = [];
            for (const i of analyzedFile.imports) {
                let filePath = utils_1.Utils.isRelative(i.file)
                    ? path_1.default.join(path_1.default.dirname(analyzedFile.filename), i.file)
                    : yield this.getRootPath(i.file);
                filePath = path_1.default.normalize(filePath);
                const contents = yield this.processFile(filePath, false, i);
                if (contents) {
                    result.push(contents);
                }
            }
            return result;
        });
    }
    getRootPath(nonRelativePath) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const root of __classPrivateFieldGet(this, _Merger_fileRoots, "f")) {
                const filePath = path_1.default.join(root, nonRelativePath);
                try {
                    yield fs_1.promises.access(filePath, fs_1.constants.R_OK);
                    return filePath;
                }
                catch (_a) {
                    debug('File %s does is not readable in root directory %s', nonRelativePath, root);
                }
            }
            return path_1.default.join(this.nodeModulesRoot, nonRelativePath);
        });
    }
    processExports(analyzedFile, parentImport) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = [];
            analyzedFile.exports.forEach((e) => {
                const fileExports = this.processExport(analyzedFile, e, parentImport);
                result.push(...fileExports);
            });
            return result;
        });
    }
    processExport(analyzedFile, e, parentImport) {
        const isAllImport = importsAnalyzer_1.ImportsAnalyzer.isAllImport(parentImport);
        const isRenameGlobalImport = importsAnalyzer_1.ImportsAnalyzer.isRenameGlobalImport(parentImport);
        const shouldBeImported = (exportName) => {
            var _a;
            if (e.type === types_1.ExportType.comment &&
                (isAllImport || isRenameGlobalImport)) {
                return true;
            }
            return (isAllImport ||
                isRenameGlobalImport ||
                ((_a = parentImport === null || parentImport === void 0 ? void 0 : parentImport.namedImports) === null || _a === void 0 ? void 0 : _a.find((namedImport) => namedImport.name === exportName)));
        };
        const result = [];
        const beImported = shouldBeImported(e.name);
        let rename = typeof beImported === 'object' && beImported !== null
            ? beImported.as
            : null;
        const isImported = this.importRegistry.isImported(analyzedFile.filename, e.name, rename);
        if (isImported) {
            debug('%s Already imported: %s %s', '⚠', e.name, analyzedFile.filename);
            return [];
        }
        if (beImported) {
            if (isRenameGlobalImport && parentImport) {
                rename = `${parentImport.globalRenameImport}$${e.name}`;
            }
            const globalRenames = this.importRegistry.getGlobalImports();
            const newExport = __classPrivateFieldGet(this, _Merger_pluginsRegistry, "f").processExport(e);
            if (!newExport) {
                return [];
            }
            const body = fileAnalyzer_1.FileAnalyzer.buildExportBody(analyzedFile, newExport, rename, globalRenames);
            result.push(body);
            this.importRegistry.registerImport({
                as: rename,
                file: analyzedFile.filename,
                name: e.name,
                globalRename: parentImport && parentImport.globalRenameImport,
            });
        }
        return result;
    }
    stripImports(contents) {
        return contents.replace(this.getImportRegex(), '').trim();
    }
    getNodeModulesPath(file) {
        return __awaiter(this, void 0, void 0, function* () {
            return utils_1.Utils.getNodeModulesPath(file);
        });
    }
    isComment(str) {
        return str.startsWith('//') || str.startsWith('/*');
    }
}
exports.Merger = Merger;
_Merger_pluginsRegistry = new WeakMap(), _Merger_additionalRoots = new WeakMap(), _Merger_fileRoots = new WeakMap();
//# sourceMappingURL=merger.js.map