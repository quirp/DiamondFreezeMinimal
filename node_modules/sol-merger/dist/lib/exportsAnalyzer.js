"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExportsAnalyzer = void 0;
const debug_1 = __importDefault(require("debug"));
const exportVisitor_1 = require("./antlr/visitors/exportVisitor");
const types_1 = require("./types");
const error = (0, debug_1.default)('sol-merger:error');
class ExportsAnalyzer {
    constructor(contents) {
        this.contents = contents;
    }
    /**
     * Analyzes all the exports of the file (Contract, Interface, Library)
     *
     * Single export statement to process. Basically it analyzes next things:
     *
     * 1. Get the type of the export
     * 2. Get the body of the export
     * 3. Get inheritance of the specifier
     *
     */
    analyzeExports() {
        try {
            const results = [];
            const visitor = new exportVisitor_1.SolidityExportVisitor(this.contents);
            visitor.visit((e) => {
                if (e.type === types_1.ExportType.constant) {
                    const constantExport = this.analyzeExportConstant(e);
                    results.push(constantExport);
                    return;
                }
                if (e.type === types_1.ExportType.function) {
                    const functionExport = this.analyzeExportFunction(e);
                    results.push(functionExport);
                    return;
                }
                if (e.type === types_1.ExportType.userDefinedValueType) {
                    const userDefinedValueTypeExport = this.analyzeExportUserDefinedValueType(e);
                    results.push(userDefinedValueTypeExport);
                    return;
                }
                if (e.type === types_1.ExportType.usingDirective) {
                    const usingDirectiveExport = this.analyzeUsingDirective(e);
                    results.push(usingDirectiveExport);
                    return;
                }
                results.push({
                    abstract: e.abstract,
                    type: e.type,
                    name: e.name,
                    body: this.contents.substring(e.body.start, e.body.end + 1).trim(),
                    is: e.is
                        ? this.contents.substring(e.is.start, e.is.end + 1).trimLeft()
                        : '',
                });
            });
            return results;
        }
        catch (e) {
            error(e);
            return [];
        }
    }
    analyzeExportConstant(e) {
        return {
            body: this.contents.substring(e.body.start, e.body.end + 1),
            name: e.name,
            type: types_1.ExportType.constant,
            typeName: e.typeName,
        };
    }
    analyzeExportFunction(e) {
        return {
            body: this.contents.substring(e.start, e.end + 1),
            name: e.name,
            type: types_1.ExportType.function,
        };
    }
    analyzeExportUserDefinedValueType(e) {
        return {
            body: this.contents.substring(e.start, e.end + 1),
            name: e.name,
            type: types_1.ExportType.userDefinedValueType,
        };
    }
    analyzeUsingDirective(e) {
        return {
            body: this.contents.substring(e.start, e.end + 1),
            name: e.name,
            type: types_1.ExportType.usingDirective,
        };
    }
}
exports.ExportsAnalyzer = ExportsAnalyzer;
//# sourceMappingURL=exportsAnalyzer.js.map